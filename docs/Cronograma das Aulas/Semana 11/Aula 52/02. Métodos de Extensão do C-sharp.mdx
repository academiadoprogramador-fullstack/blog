## Introdu√ß√£o

M√©todos de Extens√£o (Extension Methods) s√£o m√©todos **est√°ticos** que permitem **adicionar novos comportamentos a tipos existentes**, sem precisar:

- Herdar da classe
- Alterar a classe original

Utilizados especialmente para:

- **Adicionar funcionalidades em classes fechadas ou de terceiros**
- Melhorar a legibilidade de c√≥digo (estilo _fluent API_)
- Manter c√≥digo coeso e reutiliz√°vel
## Caracter√≠sticas principais

- Definidos em uma **classe est√°tica**
- S√£o **m√©todos est√°ticos**
- Primeiro par√¢metro tem a palavra-chave `this` indicando o tipo a ser estendido
- Chamados como se fossem **m√©todos de inst√¢ncia**

---
## Exemplo b√°sico ‚Äî Estendendo `string`

```cs
public static class StringExtensions
{
    public static bool EstaVaziaOuNula(this string texto)
    {
        return string.IsNullOrEmpty(texto);
    }
}
```

**Uso:**

Apesar de ser um m√©todo est√°tico, voc√™ o chama **como se fosse da inst√¢ncia** (`nome.EstaVaziaOuNula()`).

```cs
string nome = "";
bool resultado = nome.EstaVaziaOuNula(); // true
```

---
## Estendendo qualquer `List<T>`

```cs
public static class ListExtensions
{
    public static void ExibirItens<T>(this List<T> lista)
    {
        foreach (T item in lista)
        {
            Console.WriteLine(item);
        }
    }
}
```

**Uso:**

```cs
var numeros = new List<int> { 1, 2, 3 };
numeros.ExibirItens();
```

---
## Vantagens dos m√©todos de extens√£o

- **Legibilidade:** permite criar chamadas encadeadas ou mais naturais.
- **Reutiliza√ß√£o:** c√≥digo centralizado e reutiliz√°vel.
- **N√£o intrusivo:** sem necessidade de alterar a classe original.
- **Permite trabalhar com interfaces e tipos fechados.**

## Regras importantes:

|Regra|Exemplo|
|---|---|
|A classe que cont√©m deve ser `static`|`public static class StringExtensions { ... }`|
|O m√©todo deve ser `static`|`public static bool EstaVaziaOuNula(this string s)`|
|O primeiro par√¢metro tem `this`|`this string s`|
|Pode ter qualquer nome|`EstaVaziaOuNula`, `DiasAteHoje`, `ExibirItens`|
|Pode ser usado em qualquer projeto|Basta importar o namespace da classe est√°tica|

---
## Aplica√ß√µes de M√©todos de Extens√£o no MVC

No contexto de **MVC**, √© muito comum precisar **converter dados de Models para ViewModels e vice-versa**.

Normalmente voc√™ teria que fazer isso **manual em cada controller**, o que pode gerar:
- C√≥digo repetitivo.
- Alta chance de erro humano.
- Dificuldade em manter padr√µes consistentes.
#### Solu√ß√£o: M√©todos de Extens√£o

Utilizando **m√©todos de extens√£o**, voc√™ consegue criar m√©todos reutiliz√°veis e limpos para mapear Models em ViewModels e vice-versa.

Isso melhora:

- **Reutiliza√ß√£o**
- **Legibilidade**
- **Organiza√ß√£o do c√≥digo**
### Exemplo com Produto e ProdutoViewModel

```cs
public class Produto
{
    public int Id { get; set; }
    public string Nome { get; set; }
    public decimal Preco { get; set; }
    public Categoria Categoria { get; set; }
}

public class Categoria
{
    public string Nome { get; set; }
}
```

```cs
public class ProdutoViewModel
{
    public int Id { get; set; }
    public string Nome { get; set; }
    public string PrecoFormatado { get; set; }
    public string NomeCategoria { get; set; }
}
```

---
### M√©todos de Extens√£o para mapeamento

```cs
public static class ProdutoExtensions
{
    // Model -> ViewModel
    public static ProdutoViewModel ParaViewModel(this Produto produto)
    {
        return new ProdutoViewModel
        {
            Id = produto.Id,
            Nome = produto.Nome,
            PrecoFormatado = produto.Preco.ToString("C2"), // R$ 1.000,00
            NomeCategoria = produto.Categoria?.Nome
        };
    }

    // ViewModel -> Model (Exemplo para POST ou PUT)
    public static Produto ParaEntidade(this ProdutoViewModel viewModel)
    {
        return new Produto
        {
            Id = viewModel.Id,
            Nome = viewModel.Nome,
            Preco = decimal.Parse(viewModel.PrecoFormatado.Replace("R$", "").Trim()),
            Categoria = new Categoria { Nome = viewModel.NomeCategoria }
        };
    }
}
```

---
### Uso pr√°tico no Controller

```cs
public class ProdutoController : Controller
{
    public IActionResult Detalhes(int id)
    {
        var produto = repositorioProduto.SelecionarPorId(id);

        var viewModel = produto.ParaViewModel();

        return View(viewModel);
    }

    [HttpPost]
    public IActionResult Editar(ProdutoViewModel viewModel)
    {
        var produto = viewModel.ParaEntidade();

        repositorioProduto.Atualizar(produto);

        return RedirectToAction("Index");
    }
}
```

---
## Vantagens de utilizar m√©todos de extens√£o para mapeamento

| Vantagem        | Descri√ß√£o                                               |
| --------------- | ------------------------------------------------------- |
| üîÅ Reutiliza√ß√£o | Mapeamento centralizado, evitando c√≥digo duplicado.     |
| üßπ Limpeza      | C√≥digo do controller mais limpo e focado na l√≥gica.     |
| ‚úÖ Consist√™ncia  | Sempre o mesmo padr√£o em toda a aplica√ß√£o.              |
| üõ° Seguran√ßa    | Evita que dados desnecess√°rios do Model sejam expostos. |
